<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Отладка on Алексей Пахунов</title>
    <link>https://blog.not-a-kernel-guy.com/tags/%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D0%BA%D0%B0/</link>
    <description>Recent content in Отладка on Алексей Пахунов</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <lastBuildDate>Mon, 16 Dec 2019 22:49:36 -0800</lastBuildDate><atom:link href="https://blog.not-a-kernel-guy.com/tags/%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D0%BA%D0%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Когда 1.0 = 0.0</title>
      <link>https://blog.not-a-kernel-guy.com/2019/12/16/gcc/</link>
      <pubDate>Mon, 16 Dec 2019 22:49:36 -0800</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2019/12/16/gcc/</guid>
      <description>&lt;p&gt;Столкнулся недавно с новой для себя областью - ловлей багов в компиляторе.
Ловить &lt;a href=&#34;https://blog.not-a-kernel-guy.com/2010/07/11/854/&#34;&gt;баг в процессоре&lt;/a&gt; мне уже доводилось, а вот с компиляторами до
недавнего времени как-то везло.&lt;/p&gt;
&lt;p&gt;Началось все очень прозаично. В нашем репозитории есть своя реализация умного
указателя. Ну, вы знаете, как это бывает. Обычная история на самом деле&amp;hellip;
Этот класс был написан в древние времена, тогда и &lt;a href=&#34;https://en.wikipedia.org/wiki/C%2B%2B03&#34;&gt;С++03&lt;/a&gt; еще на свете не
было. С тех пор уже и &lt;a href=&#34;https://en.wikipedia.org/wiki/C%2B%2B17&#34;&gt;С++17&lt;/a&gt; появился и &lt;a href=&#34;https://en.wikipedia.org/wiki/C%2B%2B20&#34;&gt;С++20&lt;/a&gt; не за горами, но класс
по-прежнему активно используется. Мы его давно хотели заменить на что-нибудь
более стандартное и современное, но все руки не доходили. “Работает - не трожь”.&lt;/p&gt;
&lt;p&gt;В один прекрасный день в этом классе нашлось &lt;a href=&#34;https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5&#34;&gt;неопределенное поведение&lt;/a&gt;, что
стало последней каплей, &lt;del&gt;переломившей верблюду соломинку&lt;/del&gt;. Указатель был
переписан на корню и стал тонкой оберткой вокруг &lt;code&gt;std::shared_ptr&amp;lt;&amp;gt;&lt;/code&gt;.
На следующий же день сломался один неприметный юнит тест на одной из платформ.
Причем на первый взгляд никакого отношения к переписанному указателю этот тест
не имел. Но от фактов было трудно отвертеться. С новым указателем тест падал, а
со старым - нет.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Как я провел прошлую пятницу</title>
      <link>https://blog.not-a-kernel-guy.com/2018/07/07/sneaky-comma/</link>
      <pubDate>Sat, 07 Jul 2018 17:09:38 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2018/07/07/sneaky-comma/</guid>
      <description>&lt;p&gt;Расскажу как я провел прошлую пятницу. Провел я её пытаясь понять, почему
простой как доска тест-кейс не работает.&lt;/p&gt;
&lt;p&gt;Тест-кейс запускает код в среде, которая симулирует полетное окружение: среду
выполнения, показания датчиков и т.д. Далее выполняется простой сценарий -
тест-кейс получает телеметрию и выполняет действия/проверки по наступлению
определенных событий. Например, тест-кейс может запустить ракету, выключить
четвертый двигатель, когда высота превысит сотню метров, а затем проверить, что
код корректно обработал нештатную ситуацию.&lt;/p&gt;
&lt;p&gt;Такие тест-кейсы, естественно, не пишутся с нуля. Кейс набирается из уже
готовых, давно написанных блоков. Что может быть очень простым делом (если есть
готовый шаблон), или не очень простым (когда такой шаблон нужно создать самому).
В этот раз случился как раз второй вариант. Когда все компоненты теста правильно
соединены остается только написать код, который ждет наступления интересных
событий и реагирует на них нужным образом.&lt;/p&gt;
&lt;p&gt;К пятнице я добрался до момента, когда сценарий тест-кейса уже написан, но еще
не работает. Сценарий вылетал по таймауту ожидая наступления одного из событий.
При этом телеметрия четко показывала, что событие наступило и у теста был вагон
времени, чтобы это заметить. Интересно, что точно такой же код, отслеживающий
другую телеметрию работал как часы. Хм.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Отладка злого бага в Go runtime</title>
      <link>https://blog.not-a-kernel-guy.com/2017/12/04/evil-go-runtime-bug/</link>
      <pubDate>Mon, 04 Dec 2017 22:50:05 -0800</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2017/12/04/evil-go-runtime-bug/</guid>
      <description>&lt;p&gt;Отличная &lt;a href=&#34;https://marcan.st/2017/12/debugging-an-evil-go-runtime-bug/&#34;&gt;статья про ловлю злого бага в Go runtime&lt;/a&gt;. Мне больше всего
понравился момент, когда выясняется, что ошибочное поведение зависит от значения
флага &lt;code&gt;CONFIG_OPTIMIZE_INLINING&lt;/code&gt;. Вроде бы и вот она причина, и вместе с тем
значение флага никак не указывает на проблемный участок кода. Автор
расследования находит отличный выход из положения&amp;hellip;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>rr</title>
      <link>https://blog.not-a-kernel-guy.com/2017/05/07/rr/</link>
      <pubDate>Sun, 07 May 2017 18:56:38 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2017/05/07/rr/</guid>
      <description>&lt;p&gt;Недавно наткнулся на &lt;a href=&#34;http://rr-project.org/&#34;&gt;rr (Record and Replay Framework)&lt;/a&gt;
от Mozilla и я вам скажу, что это просто незаменимый инструмент для ловли
неуловимых багов в отладчике. Это не первый и не единственный инструмент
подобного плана. &lt;a href=&#34;https://github.com/mozilla/rr/wiki/Related-work&#34;&gt;Соответствующая страница проекта&lt;/a&gt;
описывает десятка три альтернатив. Из этого списка мне раньше доводилось
работать только с iDNA, который впоследствии стал &lt;a href=&#34;http://www.thewindowsclub.com/microsoft-time-travel-tracing-diagnostic&#34;&gt;Time Travel Tracing
&lt;/a&gt; (TTT).
TTT мог записать процесс выполнения программы с точностью до инструкции и
воспроизвести его в точности в прямом и обратном направлении. TTT был просто
незаменим для ловли сложных багов и его главным недостатком было то, что TTT был
внутренним инструментом, который Microsoft так и не выпустила как отдельный
продукт.&lt;/p&gt;
&lt;p&gt;rr тоже может записать выполнение процесса с точностью до инструкции и проиграть
его назад и вперед. rr требует современного процессора, причем обязательно
Intel, так как использует performance counters которые не реализованы в других
процессорах. ARM и другие архитектуры тоже не поддерживаются. В обмен на это,
rr практически не замедляет записываемый процесс. Скорость выполнения падает в
1.2 раза - сущие пустяки. Размер генерируемой записи тоже крайне скромен - в
районе гигабайта за 10-15 минут выполнения “вычислительного” кода. Практически
бесплатно. В пересчете на количество выполненных инструкций получается что-то
вроде 0.1 бита на выполненную инструкцию.&lt;/p&gt;
&lt;p&gt;Что интересно, rr базируется на очень простой идее: большая часть кода
выполняется всегда одинаково. Если записать все случайные события (ввод/вывод,
RDTSC, системный вызовы) и начальные условия (содержимое памяти), то процесс
выполнения становится полностью детерминированным. Более детально можно почитать
здесь: &lt;a href=&#34;http://rr-project.org/rr.html&#34;&gt;http://rr-project.org/rr.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Процесс отладки с помощью rr выглядит так:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Записываем процесс: &lt;code&gt;rr record &amp;lt;program&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Запускаем запись в отладчике: &lt;code&gt;rr replay&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Проматываем до конца и смотрим чем вызван segfault.&lt;/li&gt;
&lt;li&gt;Ставим watchpoint на память из которой читается плохой указатель.&lt;/li&gt;
&lt;li&gt;Выполняем программу назад пока не сработает watchpoint.&lt;/li&gt;
&lt;li&gt;Смотрим почему в память пишется плохой указатель и повторяем шаги 4-6 до
победного конца.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Дополнительный бонус заключается в том, что все адреса при повторном
воспроизведении сохраняются. Если нужная переменная находится по адресу
&lt;code&gt;0x123fooba&lt;/code&gt;, то она там будет всегда. Отпадает необходимость выяснять где в
памяти находится интересный кусок каждый раз при запуске отладчика. rr также
может помечать вывод в stdout метками для быстрой перемотки в нужное место.
Это помогает сопоставить код с интересными местами в лог файлах.&lt;/p&gt;
&lt;p&gt;Само собой, у rr есть куча других ограничений. К примеру, он не работает под
Windows, не поддерживаются все системные вызовы, не поддерживается циклическая
запись (последние несколько минут выполнения процесса), поддерживается только
одно процессорное ядро, и т.д. Тем не менее, если вы столкнулись с “невозможным”
багом в Linux, rr - один из наиболее вероятных способов докопаться до источника
проблемы.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Трассировка описателей (AKA handle tracing)</title>
      <link>https://blog.not-a-kernel-guy.com/2012/12/04/1437/</link>
      <pubDate>Tue, 04 Dec 2012 23:23:13 -0800</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2012/12/04/1437/</guid>
      <description>&lt;p&gt;Начиная с Windows XP в ядро встроена поддержка трассировки описателей ядра (AKA handle tracing). Включение трассировки имеет двойной эффект. Во-первых, все операции с ядерными описателями сохраняются в циклический буфер (откуда их можно потом прочитать). Во-вторых, при любой попытке использовать несуществующий описатель генерируется исключение STATUS_INVALID_HANDLE. Фактически, проверка корректности операций с описателями в &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/windows/desktop/dd371695(v=vs.85).aspx&#34;&gt;Application Verifier&lt;/a&gt; - это тонкая обертка вокруг функций трассировки, предоставляемых ядром. Расширение отладчика !htrace - аналогично.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Overclocking и его последствия</title>
      <link>https://blog.not-a-kernel-guy.com/2012/09/25/1417/</link>
      <pubDate>Tue, 25 Sep 2012 23:01:23 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2012/09/25/1417/</guid>
      <description>&lt;p&gt;А сегодня мы с вами прослушаем лекцию о том, как избежать появления растительности на ладонях и чем её потом выводить&amp;hellip;&lt;/p&gt;
&lt;p&gt;Разбор crash dump-ов твоего приложения, собранных с пользовательских машин - занятие и увлекательное, и поучительное. Поучительное не столько потому, что демонстрирует твои собственные успехи во всей красе, но потому что не менее красиво показывает достижения других. Одновременно испытываешь и неловкость за содеянное (нахомутал, чего уж там) и гордость (да не так уж и нахомутал - посмотрите, как другие отличились), и облегчение (все одим миром мазаны). А сегодня мы разберем одно из часто встречающихся явлений - overclocking.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>minidump.py</title>
      <link>https://blog.not-a-kernel-guy.com/2012/07/12/1393/</link>
      <pubDate>Thu, 12 Jul 2012 08:51:50 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2012/07/12/1393/</guid>
      <description>Если вам вдруг зачем-то понадобилось проанализировать структуру минидампа не загружая его в отладчик, начните вот с этой статьи: http://moyix.blogspot.com/2008/05/parsing-windows-minidumps.html. Автор написал скрипт на Python (на основе Construct) для анализа дампов, который распознает все потоки, описанные на MSDN (а также недокументированный поток, хранящий информацию об описателях окон).
PS. Скрипт открывает дамп в текстовом режиме, что очевидно не будет работать на Windows. Чтобы этого не случилось, последняя строчка скипта должна выглядеть вот так:</description>
    </item>
    
    <item>
      <title>Inception</title>
      <link>https://blog.not-a-kernel-guy.com/2011/04/07/1020/</link>
      <pubDate>Thu, 07 Apr 2011 23:38:25 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2011/04/07/1020/</guid>
      <description>&lt;p&gt;Сижу я сегодня на работе, никого не трогаю, отладчиком отладчик отлаживаю. А что, отладчик - тоже &lt;!-- raw HTML omitted --&gt;человек&lt;!-- raw HTML omitted --&gt; программа. Тем более что немногим ранее я его немножко совсем поломал, пытаясь добавить поддержку некоей конфигурации, которая текущей реинкарнацией отладчика не поддерживается. Ну вот, запускаю я его примерно вот таким образом:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-no-highlight&#34; data-lang=&#34;no-highlight&#34;&gt;windbg.exe kd.exe -k com:port=com1,baud=115200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;…и замечаю, что что-то не так. А именно - опять сломался наш корпоративный прокси. А я как раз хотел посмотреть в… ну скажем MSDN. Попробовал и так и сяк. Не работает, вылетает по таймауту. Ну хорошо, но тут начитают происходить еще более мистические вещи. Outlook вдруг перестает реагировать мышь и клавиатуру; IE вообще не запускается – процесс стартует, но окно не показывается. Несколько подозрительно для проблем с прокси.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>NDIS, !ndiskd и DML</title>
      <link>https://blog.not-a-kernel-guy.com/2011/02/06/972/</link>
      <pubDate>Sun, 06 Feb 2011 22:19:08 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2011/02/06/972/</guid>
      <description>&lt;p&gt;На работе понадобилось написать драйвер для сетевой карты. Я этого раньше никогда не делал и вообще с &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms817945.aspx&#34;&gt;NDIS&lt;/a&gt; дела не имел. А тут такая возможность! Делюсь впечатлениями.&lt;/p&gt;
&lt;p&gt;В общем и целом NDIS мне понравился. Интерфейсы довольно логичны, хотя и многочисленны. Взаимосвязь между разными компонентами в большинстве случаев после недолгой медитации становится довольно очевидной. Все структуры снабжены заголовком с сигнатурой, версией и размером, что, помимо заботы об обратной совместимости, означает меньше проблем с отладкой. При необходимости нужную структуру можно просто найти в памяти.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Отладка NMAKE скриптов</title>
      <link>https://blog.not-a-kernel-guy.com/2010/10/30/915/</link>
      <pubDate>Sat, 30 Oct 2010 00:19:19 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2010/10/30/915/</guid>
      <description>Раз уж я заговорил про BUILD и NMAKE, то вот несколько простых (и, в общем-то, очевидных) способов отладки NMAKE скриптов.
  Директива препроцессора !ERROR очень полезна, когда нужно выяснить доходит ли управление до интересующей нас линии скрипта. Директива выводит указанный текст в сообщении об ошибке (U1050) и останавливает NMAKE.
  !MESSAGE пригодится для дампа макросов в лог. Например:
  !MESSAGE BUILD_PASS = $(BUILD_PASS) Выведет в лог номер прохода (PASS0, PASS1 или PASS2), в случае, если NMAKE, был запущен через BUILD в билд-окружении WDK.</description>
    </item>
    
    <item>
      <title>Как запустить «посторонний» бинарник под отладчиком в Visual Studio?</title>
      <link>https://blog.not-a-kernel-guy.com/2010/09/14/891/</link>
      <pubDate>Tue, 14 Sep 2010 22:17:21 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2010/09/14/891/</guid>
      <description>Visual Studio предлагает два основных отладочных сценария:
  Собрать проект и запустить результат под отладчиком.
  Присоединиться к уже запущеному процессу.
  Третьей опции, – запустить произвольный бинарник под отладчиком, явно не предлагается, что вызывает смятение и смуту в рядах программистов, не нюхавших WinDbg. Вот один из способов как этого можно добиться.
  Создаем новый проект. Тип проекта выбираем “Makefile project”.
  В качестве команды сборки, очистки и пересборки проекта указываем “echo.</description>
    </item>
    
    <item>
      <title>Про OutputDebugString</title>
      <link>https://blog.not-a-kernel-guy.com/2010/07/14/859/</link>
      <pubDate>Wed, 14 Jul 2010 08:58:59 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2010/07/14/859/</guid>
      <description>Тут интересная дискуссия про &amp;ldquo;неработающую&amp;rdquo; OutputDebugString завязалась в комментариях, если кто пропустил. Читать вот примерно отсюда.</description>
    </item>
    
    <item>
      <title>Пошли мы как-то с коллегой на охоту…</title>
      <link>https://blog.not-a-kernel-guy.com/2010/07/11/854/</link>
      <pubDate>Sun, 11 Jul 2010 14:10:10 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2010/07/11/854/</guid>
      <description>&lt;p&gt;Давно я про отладку не писал. Так вот пошли мы как-то с коллегой на Багов охотится. Вышли мы на двух таких матерых, опытных Багов. Их и помотали они нас…&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Символы для release сборки</title>
      <link>https://blog.not-a-kernel-guy.com/2010/01/05/744/</link>
      <pubDate>Tue, 05 Jan 2010 23:01:43 -0800</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2010/01/05/744/</guid>
      <description>В очередной раз столкнулся с мифом, что, мол, release сборку невозможно отлаживать, так как символов нет. Значит так! Американцы на Луне были!Тьфу ты. В смысле, символы в release сборке включать: а) можно, б) нужно и в) полезно. Генерация отладочной информации не влияет на оптимизацию кода. Хотите, проверьте сами – сравните ассемблерные листинги с генерацией символов и без. Более того, случаи, когда это не так, однозначно трактуются как ошибки, которые можно смело отправлять в Microsoft.</description>
    </item>
    
    <item>
      <title>Отладка на кофейной гуще</title>
      <link>https://blog.not-a-kernel-guy.com/2009/05/22/532/</link>
      <pubDate>Fri, 22 May 2009 23:51:35 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2009/05/22/532/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://blog.not-a-kernel-guy.com/2009/05/mall_fortunecrystalball.gif&#34; alt=&#34;mall_fortunecrystalball&#34;&gt;При определённой сноровке, можно отлаживать код прямо из любимого почтового клиента. На днях пришло письмо с вопросом. Некоторое приложение, будучи установленным в каталог отличный от “Program Files”, при запуске вызывало появление окна &lt;a href=&#34;http://en.wikipedia.org/wiki/User_Account_Control&#34;&gt;UAC&lt;/a&gt; с требованием повысить привилегии. Приложение работало нормально, в случае, если оно было установлено в “Program Files”. Как такое может быть?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Как отлаживать код незнакомых приложений?</title>
      <link>https://blog.not-a-kernel-guy.com/2009/05/17/521/</link>
      <pubDate>Sun, 17 May 2009 22:43:10 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2009/05/17/521/</guid>
      <description>&lt;p&gt;… легко постукивая кувалдой.&lt;/p&gt;
&lt;p&gt;Вопрос из почты:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Я пытаюсь приспособить windbg не для отладки, а для реверсинга незнакомых приложений, и постоянно упираюсь в то, что для удобной работы нужны символы, иначе windbg (в юзермоде, конечно) ничем не сильнее того же OllyDbg. Но, я надеюсь, что не все так плохо с этим отладчиком, и это у меня руки кривые.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Расширение для WinDbg: «Outline»</title>
      <link>https://blog.not-a-kernel-guy.com/2009/05/16/512/</link>
      <pubDate>Sat, 16 May 2009 22:45:18 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2009/05/16/512/</guid>
      <description>&lt;p&gt;Мне частенько приходится разбираться с отладкой исключений, произошедших из-за порчи стека или на фоне порчи стека. В таких случаях обычно приходится трассировать стек вручную. Дело это муторное, поэтому я решил написать расширение для WinDbg, несколько облегчающее эту задачу.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Маленькие хитрости «посмертной» отладки</title>
      <link>https://blog.not-a-kernel-guy.com/2009/02/08/434/</link>
      <pubDate>Sun, 08 Feb 2009 22:33:02 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2009/02/08/434/</guid>
      <description>&lt;p&gt;Как то заметил, что в списке запущенных процессов постоянно болтается три штуки cdb.exe:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.not-a-kernel-guy.com/2009/02/aedebug_cdb.png&#34; alt=&#34;aedebug_cdb&#34;&gt;&lt;/p&gt;
&lt;p&gt;CDB – это консольная версия WinDbg, которая у меня установлена в качестве &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/cc266343.aspx&#34;&gt;«посмертного» отладчика (postmortem debugger)&lt;/a&gt;.Обычно при этом падение приложения не проходит незамеченным - запускается консоль отладчика на весь экран. Трудно не заметить. В данном же случае, по всей видимости, фатальное исключение случалось в привилегированном процессе в отдельной сессии, соответственно и консоль создавалась в другой сессии.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Прелести отладки</title>
      <link>https://blog.not-a-kernel-guy.com/2009/01/14/417/</link>
      <pubDate>Wed, 14 Jan 2009 23:25:05 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2009/01/14/417/</guid>
      <description>&lt;p&gt;Процесс отладки, насколько я могу судить, наполовину состоит невнятного мычания, пожимания плечами и чесания в затылке. Процентов двадцать занимает нудное «копание» в отладчике или поиски крупиц полезной информации в логах. Живое воображение с элементами садизма: «а вот мы его еще так попробуем, сверху трейсером придавим, а снизу KD подопрем», берет на себя еще десяток. Чистая удача, хорошая память «где-то я это уже видел» и занудство «а вот почему ту запятая не на месте?» вместе составят – еще десять. Причем на удачу из них приходится ровно 0.42%. Западло, а также строгое выполнение всех законов Мерфи, - и вот еще 9%. На заветное «Эврика! Нашел!» практически ничего не остается. :-(&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>За последние две-три недели узнал много нового...</title>
      <link>https://blog.not-a-kernel-guy.com/2008/03/27/300/</link>
      <pubDate>Thu, 27 Mar 2008 21:40:52 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2008/03/27/300/</guid>
      <description>&lt;p&gt;За последние две-три недели узнал много нового про архитектуру amd64. Во-первых, я наткнулся сначала на документ, а затем на аналогичный &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/7kcdt6fy(VS.80).aspx&#34;&gt;раздел в MSDN&lt;/a&gt;, где толково описаны не только &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/9b372w95%28VS.80%29.aspx&#34;&gt;соглашения о вызовах&lt;/a&gt; (этого добра везде навалом), но и дано детальное описание того, как должен выглядеть &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/x4ea06t0%28VS.80%29.aspx&#34;&gt;стек функции&lt;/a&gt;, как происходит &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/8ydc79k6(VS.80).aspx&#34;&gt;раскрутка стека&lt;/a&gt;, что такое и зачем нужны &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/tawsa7cb%28VS.80%29.aspx&#34;&gt;пролог и эпилог функции&lt;/a&gt;. Полезный документ, особенно если нужно разобраться как работает stack unwinder.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Process Monitor научился трассировать 32-х битный стек на x64</title>
      <link>https://blog.not-a-kernel-guy.com/2008/03/23/299/</link>
      <pubDate>Sun, 23 Mar 2008 22:46:19 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2008/03/23/299/</guid>
      <description>&lt;p&gt;Я как-то привык, что Process Monitor не умеет показывать 32-х битный стек события, которое произошло в 32-х разрядном процессе, выполняющемся под Wow64. Вместо этого он показывал только 64-х битный стек, что было абсолютно бесполезно, так как там по определению всегда светится wow64.dll сотоварищи. Однако после подсказки на &lt;a href=&#34;http://forum.sysinternals.com/forum_posts.asp?TID=13227#65748&#34;&gt;Sysinternals Forums&lt;/a&gt; выяснилось, что начиная с Vista SP1 это уже работает.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Разрядность ключа «Image File Execution Options»</title>
      <link>https://blog.not-a-kernel-guy.com/2008/01/09/277/</link>
      <pubDate>Wed, 09 Jan 2008 23:34:16 -0800</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2008/01/09/277/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blogs.msdn.com/junfeng/archive/2004/04/28/121871.aspx&#34;&gt;Ключ «Image File Execution Options»&lt;/a&gt; знаком, наверное, всем кто вынужден тратить много времени на отладку приложений. В частности, с его помощью можно указать системе всегда запускать определённый процесс под отладчиком. В этом же ключе &lt;a href=&#34;http://technet2.microsoft.com/windowsserver/en/library/b6af1963-3b75-42f2-860f-aff9354aefde1033.mspx?mfr=true&#34;&gt;утилита gflags.exe&lt;/a&gt; сохраняет выбранные отладочные опции и т.д. За подробностями рекомендую обратиться в Google, там есть много полезного.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Как посмотреть содержимое реестра из-под отладчика</title>
      <link>https://blog.not-a-kernel-guy.com/2007/12/29/274/</link>
      <pubDate>Sat, 29 Dec 2007 23:24:18 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2007/12/29/274/</guid>
      <description>&lt;p&gt;_Сижу дома простуженный. Ни о чём писать не хочется, поэтому буду краток. _&lt;/p&gt;
&lt;p&gt;Команда !dreg в WinDbg позволяет просматривать содержимое реестра прямо в процессе отладки. Это особенно удобно в двух случаях:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;При удалённой отладке, когда сессия отладчика - это единственный вид доступа к удалённой машине. Такое встречается сплошь и рядом, например, если удалённая машина находится в другой сети или домене;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;В случае, когда отладчик пользовательского режима контролируется ядерным отладчиком. Это тоже, в общем-то, &lt;a href=&#34;http://www.nynaeve.net/?p=30&#34;&gt;вариант удалённой отладки&lt;/a&gt;, только в этом случае до отлаживаемой машины достучаться кроме как через отладчик вообще никак нельзя.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;К сожалению !dreg не работает в ядерном отладчике, вернее работает, но показывает реестр той машины где запущен kd.exe, а не целевой, так бы этого не хотелось. Иначе бы счастье было бы полным.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Говорила мне мама – сынок, проверяй результат каждой вызванной функции!</title>
      <link>https://blog.not-a-kernel-guy.com/2007/11/29/266/</link>
      <pubDate>Thu, 29 Nov 2007 23:03:15 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2007/11/29/266/</guid>
      <description>&lt;p&gt;На днях в очередной раз попробовал поставить &lt;a href=&#34;http://punto.ru/&#34;&gt;Punto Switcher&lt;/a&gt; после того, как на глаза попалась заметка о выходе версии, совместимой с Vista. Надо сказать, что я это делаю периодически, - в смысле устанавливаю Punto Switcher, играюсь с ним какое-то время, а потом удаляю. Честно говоря, я и сам не очень понимаю, почему он у меня не приживается. СОвсем неплохо напсаная программа. Какая-то тотальная несправедливость с моей стороны. Хотя нет, в последний раз причина была в том, что он не поддерживает 64-х битные версии Windows.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>“4GB will always be enough”</title>
      <link>https://blog.not-a-kernel-guy.com/2007/10/18/256/</link>
      <pubDate>Thu, 18 Oct 2007 21:50:34 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2007/10/18/256/</guid>
      <description>&lt;p&gt;Порой разработчики приложений просто поражают своей храбростью и безудержным оптимизмом. Свежий пример - на днях получаю письмо с просьбой разобраться почему 32-битное приложение, нормально работавшее в Windows Server 2003 for Itanium перестало запускаться в Windows Server 2008 for Itanium. Что особенно приятно, так это то, что вместо традиционного «приложение падает, если сделать то, то и вот то», просто прислали сессию отладчика, остановленную непосредственно перед вызовом NtAllocateVirtualMemory, который и приводил к падению.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
