<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Git on Алексей Пахунов</title>
    <link>https://blog.not-a-kernel-guy.com/tags/git/</link>
    <description>Recent content in Git on Алексей Пахунов</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <lastBuildDate>Tue, 15 May 2018 22:46:12 -0700</lastBuildDate>
    <atom:link href="https://blog.not-a-kernel-guy.com/tags/git/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SubGit</title>
      <link>https://blog.not-a-kernel-guy.com/2018/05/15/subgit/</link>
      <pubDate>Tue, 15 May 2018 22:46:12 -0700</pubDate>
      <guid>https://blog.not-a-kernel-guy.com/2018/05/15/subgit/</guid>
      <description>&lt;p&gt;Получил непрошенное подтверждение &lt;a href=&#34;https://blog.not-a-kernel-guy.com/2018/04/22/svn-git/&#34;&gt;тезиса про вред реализации веток через&#xA;операцию копирования в Subversion&lt;/a&gt;. Вторую неделю бодаюсь с импортом SVN в&#xA;Git с помощью &lt;a href=&#34;https://subgit.com/&#34;&gt;SubGit&lt;/a&gt;. SubGit довольно неплохо с этим справляется. Особенно&#xA;хорошо то, что он может постоянно синхронизировать SVN и Git, делая переход с&#xA;одного на другой плавным и безболезненным. Он даже со всякими&#xA;противоестественными манипуляциями со структурой веток в SVN репозитории&#xA;справляется.&lt;/p&gt;&#xA;&lt;p&gt;Но и на старуху найдется свой Раскольников. При создании одного из зеркал был&#xA;указан не корневой адрес SVN, а https://foobar/svn/xyz. Зеркало прекрасно&#xA;жило своей зеркальной жизню, пока не было обнаружено, что часть истории&#xA;отсутствует. Для её восстановления родился план - заново импортировать все из&#xA;корня (https://foobar/svn), а затем, уже на стороне Git, - сшить старую и новую&#xA;историю вместе.&lt;/p&gt;&#xA;&lt;p&gt;Отличный был план. И, что самое главное, и SubGit и Git все эти фокусы позволяют&#xA;и поддерживают. За одним маленьким исключением&amp;hellip; Как выяснилось, менять адрес&#xA;с https://foobar/svn/xyz на https://foobar/svn категорически не получается.&#xA;Вернее получается, но результат выходит как-то не очень. SubGit пытается&#xA;импортировать историю (и находит все правильные коммиты, что характерно), но&#xA;затем пытается заново засунуть их обратно в SVN. SVN кричит &amp;ldquo;что вы в меня это&#xA;пихаете?&amp;rdquo; SubGit ужасно смущается, бормочет многоэтажные стек-трейсы в лог и&#xA;заодно сносит &lt;code&gt;master&lt;/code&gt; к праотцам.&lt;/p&gt;&#xA;&lt;p&gt;Эх&amp;hellip; Буду теперь с &lt;code&gt;git replace&lt;/code&gt; возится&amp;hellip;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Трассировка команд в Git</title>
      <link>https://blog.not-a-kernel-guy.com/2018/04/29/git-tracing/</link>
      <pubDate>Sun, 29 Apr 2018 20:10:58 -0700</pubDate>
      <guid>https://blog.not-a-kernel-guy.com/2018/04/29/git-tracing/</guid>
      <description>&lt;p&gt;Недавно разбирался почему клонирование большого репозитория в Git занимает так&#xA;много времени. Текущая версия ответа &amp;ldquo;ну репозиторий же большой, что ж вы&#xA;хотели-то?&amp;rdquo; звучит логично, но все равно руки чешутся найти какую-нибудь&#xA;глупость и ускорить этот процесс раза в два. Пока что-то не очень получается&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;Пока копался в недрах наткнулся на то, что Git содержит встроенную трассировку&#xA;команд. Трассировка включается через &lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Internals-Environment-Variables&#34;&gt;переменные окружения вида &lt;code&gt;GIT_TRACE_XXX&lt;/code&gt;&lt;/a&gt;.&#xA;Если значение переменной &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; или &lt;code&gt;2&lt;/code&gt; - отладочные сообщения будут&#xA;писаться в &lt;code&gt;stderr&lt;/code&gt;. Если значение переменной - абсолютный путь, начинающийся с&#xA;&lt;code&gt;/&lt;/code&gt;, то отладочные сообщения будут писаться в этот файл.&lt;/p&gt;&#xA;&lt;p&gt;Поддерживаются следующие категории сообщений:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;GIT_TRACE&lt;/code&gt;: общие сообщения, которые не попали в другие категории.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;GIT_TRACE_PACK_ACCESS&lt;/code&gt;: отладка обращений к &lt;code&gt;.pack&lt;/code&gt; файлам.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;GIT_TRACE_PACKET&lt;/code&gt;: трассировка пакетов для сетевых операций.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt;: выдает информацию о производительности - в основном&#xA;меряет время, затраченное различными операциями.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;GIT_TRACE_SETUP&lt;/code&gt;: выводит информацию о рабочей копии и окружении.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Разные категории сообщений могут писаться в один файл. Новые сообщения&#xA;дописываются в конец файла.&lt;/p&gt;&#xA;&lt;p&gt;Возможность писать сообщения в файл особенно удобна. К примеру, я добавил&#xA;&lt;code&gt;export GIT_TRACE_PERFORMANCE=/home/&amp;lt;user&amp;gt;/git_trace.log&lt;/code&gt; в &lt;code&gt;.zshrc&lt;/code&gt; и теперь&#xA;если Git неожиданно замирает на ровном месте, &lt;code&gt;tail -n30 ~/git_trace.txt&lt;/code&gt; выдает&#xA;мне сводку где Git проводит больше всего времени.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ошибки дизайна</title>
      <link>https://blog.not-a-kernel-guy.com/2018/04/22/svn-git/</link>
      <pubDate>Sun, 22 Apr 2018 18:47:23 -0700</pubDate>
      <guid>https://blog.not-a-kernel-guy.com/2018/04/22/svn-git/</guid>
      <description>&lt;p&gt;А давайте про ошибки в дизайне поговорим. Тем более, что задним умом мы тут&#xA;самые умные&amp;hellip; Я в последнее время много играюсь с миграцией &lt;a href=&#34;https://subversion.apache.org/&#34;&gt;Subversion&lt;/a&gt; на&#xA;&lt;a href=&#34;https://git-scm.com/&#34;&gt;Git&lt;/a&gt; и многие их косяки так в глаза и лезут.&lt;/p&gt;&#xA;&lt;p&gt;Начнем с Subversion. Во времена массового перехода с &lt;a href=&#34;https://en.wikipedia.org/wiki/Concurrent_Versions_System&#34;&gt;CVS&lt;/a&gt; на Subversion,&#xA;одним из главных аргументов &amp;ldquo;за&amp;rdquo; была поддержка директорий и операций&#xA;копирования/перемещения в Subversion. Было видно, что разработчикам поддержка&#xA;копирования очень пришлась по душе. Насколько пришлась, что и ветки в Subversion&#xA;создаются через копирование, а структура репозитория по-умолчанию - это&#xA;знаменитые три директории &lt;code&gt;trunk&lt;/code&gt;, &lt;code&gt;branches&lt;/code&gt; и &lt;code&gt;tags&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Я догадываюсь как принималось это решение. Что-нибудь в духе &amp;ldquo;прикиньте,&#xA;одна операция поддерживает и копирование, и ветки, и метки. Не нужно писать&#xA;новый код для отдельного пространства имен веток. У нас уже есть этот код&amp;rdquo;. Но&#xA;если пересчитать набитые шишки, то становится понятно, что решение было так&#xA;себе&amp;hellip; не очень&amp;hellip; совсем хреновое решение это было, как оказалось.&lt;/p&gt;&#xA;&lt;p&gt;Почему? А вот почему. Корректная работа с путями файлов, не смотря на кажущуюся&#xA;простоту, - это постоянный источник багов. Казалось бы, что тут может быть&#xA;сложного, но в результате получается как с указателями - нет, нет, а обязательно&#xA;один потеряется. А Subversion заставляет с путями работать.&lt;/p&gt;&#xA;&lt;p&gt;Скажем количество шагов в пути для &lt;code&gt;trunk&lt;/code&gt; и &lt;code&gt;branches/foobar&lt;/code&gt; разная. Это&#xA;значит, что любой скрипт должен это корректно обработать. Не существует способа&#xA;найти все ветки в произвольном репозитории. Операция копирования не обязательно&#xA;означает создание ветки - а значит без какого-нибудь соглашения не обойтись.&#xA;Ну а мы знаем насколько хорошо &lt;a href=&#34;https://xkcd.com/927/&#34;&gt;люди выдумывают совместимые стандарты&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Использование копирования для создания веток автоматически означает, что&#xA;Subversion создать рабочую копию из людой директории в репозитории. Отличная&#xA;оптимизация, когда нужно выкачать один файл, но, опять же, это означает, что&#xA;скрипты не могут делать массы полезных предположений о структуре репозитория.&#xA;Практически сразу же вся эта гибкость запрещается и создается wiki страничка&#xA;&amp;ldquo;чекаут делается так, а ветки называются только так, а всех кто делает не так -&#xA;прибью нафиг&amp;rdquo;.&lt;/p&gt;&#xA;&lt;p&gt;Теперь давайте про Git. Линус выбрал другую крайность. Вместо того, чтобы&#xA;оставить поддержку копирования для файлов, но сделать нормальные ветки, он&#xA;сделал нормальные ветки, но выкорчевал поддержку операций копирования. За одно&#xA;под раздачу попали пустые директории.&lt;/p&gt;&#xA;&lt;p&gt;Объяснение, как я его понимаю, тут такое - ни копирование, ни пустые директории&#xA;с точки зрения самой системы контроля версий не несут полезной информации. Они&#xA;совершенно не нужны чтобы корректно отслеживать версии исходного кода. Более&#xA;того, эффективное использование Git подразумевает, что никто не анализирует&#xA;историю изменений коммит за коммитом. Вместо этого история - это просто такая&#xA;база данных, хранящая связи между изменениями в коде, и работать с ней нужно как&#xA;с базой данных - с помощью языка запросов, оперируя большими наборами коммитов&#xA;(т.е. ветками). Полноценная поддержка операции копирования означает, слияние&#xA;веток требует анализа каждого коммита между этими ветками (медленно). Git же&#xA;обходится только анализом начального и конечного состояния дерева файлов,&#xA;пропуская промежуточные состояния.&lt;/p&gt;&#xA;&lt;p&gt;Что же тут плохого, спросите вы? В данном случае проблема упирается в психологию&#xA;людей. Да, соглашается подавляющее большинство разработчиков, - поддержка&#xA;копирования и пустые директории в принципе не нужны. Но! Мы к ним так привыкли.&#xA;Мы хотим линейную историю, явную поддержку копирования и пустые директории.&#xA;Нам без них не уютно.&lt;/p&gt;&#xA;&lt;p&gt;Вы будете смеяться, но это реальная проблема. Особенно, когда мигрируешь с&#xA;Subversion на Git.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Но ведь оно раньше работало. Я мог сделать так и так.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Полностью согласен, но, на кой, простите, вам это нужно делать именно таким&#xA;способом?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Но ведь это единственный правильный способ. Мы так всегда делали&amp;hellip;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;У нас на работе есть коробка с плюшевыми медведями - специально для таких&#xA;случаев. Когда ситуация заходит в тупик и разумные аргументы уже не помогают в&#xA;дело вступают плюшевые медведи. Коллеге, чью любимую &lt;a href=&#34;https://xkcd.com/1172/&#34;&gt;фичу пришлось отдать в&#xA;жертву прогрессу&lt;/a&gt;, на руки выдается плюшевый медведь - дабы облегчить тяжесть&#xA;утраты.&lt;/p&gt;</description>
    </item>
    <item>
      <title>git merge vs git rebase</title>
      <link>https://blog.not-a-kernel-guy.com/2017/09/22/git-merge-rebase/</link>
      <pubDate>Fri, 22 Sep 2017 20:08:39 -0700</pubDate>
      <guid>https://blog.not-a-kernel-guy.com/2017/09/22/git-merge-rebase/</guid>
      <description>&lt;p&gt;Прелесть какая:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://pbs.twimg.com/media/DJ9dW0BW4AEwGOW.jpg:large&#34;&gt;&lt;img src=&#34;https://blog.not-a-kernel-guy.com/2017/09/git-merge-rebase.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
