<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Git on Алексей Пахунов</title>
    <link>https://blog.not-a-kernel-guy.com/tags/git/</link>
    <description>Recent content in Git on Алексей Пахунов</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <lastBuildDate>Tue, 15 May 2018 22:46:12 -0700</lastBuildDate>
    
	<atom:link href="https://blog.not-a-kernel-guy.com/tags/git/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SubGit</title>
      <link>https://blog.not-a-kernel-guy.com/2018/05/15/subgit/</link>
      <pubDate>Tue, 15 May 2018 22:46:12 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2018/05/15/subgit/</guid>
      <description>&lt;p&gt;Получил непрошенное подтверждение &lt;a href=&#34;https://blog.not-a-kernel-guy.com/2018/04/22/svn-git/&#34;&gt;тезиса про вред реализации веток через
операцию копирования в Subversion&lt;/a&gt;. Вторую неделю бодаюсь с импортом SVN в
Git с помощью &lt;a href=&#34;https://subgit.com/&#34;&gt;SubGit&lt;/a&gt;. SubGit довольно неплохо с этим справляется. Особенно
хорошо то, что он может постоянно синхронизировать SVN и Git, делая переход с
одного на другой плавным и безболезненным. Он даже со всякими
противоестественными манипуляциями со структурой веток в SVN репозитории
справляется.&lt;/p&gt;

&lt;p&gt;Но и на старуху найдется свой Раскольников. При создании одного из зеркал был
указан не корневой адрес SVN, а &lt;a href=&#34;https://foobar/svn/xyz&#34;&gt;https://foobar/svn/xyz&lt;/a&gt;. Зеркало прекрасно
жило своей зеркальной жизню, пока не было обнаружено, что часть истории
отсутствует. Для её восстановления родился план - заново импортировать все из
корня (&lt;a href=&#34;https://foobar/svn&#34;&gt;https://foobar/svn&lt;/a&gt;), а затем, уже на стороне Git, - сшить старую и новую
историю вместе.&lt;/p&gt;

&lt;p&gt;Отличный был план. И, что самое главное, и SubGit и Git все эти фокусы позволяют
и поддерживают. За одним маленьким исключением&amp;hellip; Как выяснилось, менять адрес
с &lt;a href=&#34;https://foobar/svn/xyz&#34;&gt;https://foobar/svn/xyz&lt;/a&gt; на &lt;a href=&#34;https://foobar/svn&#34;&gt;https://foobar/svn&lt;/a&gt; категорически не получается.
Вернее получается, но результат выходит как-то не очень. SubGit пытается
импортировать историю (и находит все правильные коммиты, что характерно), но
затем пытается заново засунуть их обратно в SVN. SVN кричит &amp;ldquo;что вы в меня это
пихаете?&amp;rdquo; SubGit ужасно смущается, бормочет многоэтажные стек-трейсы в лог и
заодно сносит &lt;code&gt;master&lt;/code&gt; к праотцам.&lt;/p&gt;

&lt;p&gt;Эх&amp;hellip; Буду теперь с &lt;code&gt;git replace&lt;/code&gt; возится&amp;hellip;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Трассировка команд в Git</title>
      <link>https://blog.not-a-kernel-guy.com/2018/04/29/git-tracing/</link>
      <pubDate>Sun, 29 Apr 2018 20:10:58 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2018/04/29/git-tracing/</guid>
      <description>&lt;p&gt;Недавно разбирался почему клонирование большого репозитория в Git занимает так
много времени. Текущая версия ответа &amp;ldquo;ну репозиторий же большой, что ж вы
хотели-то?&amp;rdquo; звучит логично, но все равно руки чешутся найти какую-нибудь
глупость и ускорить этот процесс раза в два. Пока что-то не очень получается&amp;hellip;&lt;/p&gt;

&lt;p&gt;Пока копался в недрах наткнулся на то, что Git содержит встроенную трассировку
команд. Трассировка включается через &lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Internals-Environment-Variables&#34;&gt;переменные окружения вида &lt;code&gt;GIT_TRACE_XXX&lt;/code&gt;&lt;/a&gt;.
Если значение переменной &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; или &lt;code&gt;2&lt;/code&gt; - отладочные сообщения будут
писаться в &lt;code&gt;stderr&lt;/code&gt;. Если значение переменной - абсолютный путь, начинающийся с
&lt;code&gt;/&lt;/code&gt;, то отладочные сообщения будут писаться в этот файл.&lt;/p&gt;

&lt;p&gt;Поддерживаются следующие категории сообщений:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GIT_TRACE&lt;/code&gt;: общие сообщения, которые не попали в другие категории.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GIT_TRACE_PACK_ACCESS&lt;/code&gt;: отладка обращений к &lt;code&gt;.pack&lt;/code&gt; файлам.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GIT_TRACE_PACKET&lt;/code&gt;: трассировка пакетов для сетевых операций.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt;: выдает информацию о производительности - в основном
меряет время, затраченное различными операциями.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GIT_TRACE_SETUP&lt;/code&gt;: выводит информацию о рабочей копии и окружении.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Разные категории сообщений могут писаться в один файл. Новые сообщения
дописываются в конец файла.&lt;/p&gt;

&lt;p&gt;Возможность писать сообщения в файл особенно удобна. К примеру, я добавил
&lt;code&gt;export GIT_TRACE_PERFORMANCE=/home/&amp;lt;user&amp;gt;/git_trace.log&lt;/code&gt; в &lt;code&gt;.zshrc&lt;/code&gt; и теперь
если Git неожиданно замирает на ровном месте, &lt;code&gt;tail -n30 ~/git_trace.txt&lt;/code&gt; выдает
мне сводку где Git проводит больше всего времени.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ошибки дизайна</title>
      <link>https://blog.not-a-kernel-guy.com/2018/04/22/svn-git/</link>
      <pubDate>Sun, 22 Apr 2018 18:47:23 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2018/04/22/svn-git/</guid>
      <description>&lt;p&gt;А давайте про ошибки в дизайне поговорим. Тем более, что задним умом мы тут
самые умные&amp;hellip; Я в последнее время много играюсь с миграцией &lt;a href=&#34;https://subversion.apache.org/&#34;&gt;Subversion&lt;/a&gt; на
&lt;a href=&#34;https://git-scm.com/&#34;&gt;Git&lt;/a&gt; и многие их косяки так в глаза и лезут.&lt;/p&gt;

&lt;p&gt;Начнем с Subversion. Во времена массового перехода с &lt;a href=&#34;https://en.wikipedia.org/wiki/Concurrent_Versions_System&#34;&gt;CVS&lt;/a&gt; на Subversion,
одним из главных аргументов &amp;ldquo;за&amp;rdquo; была поддержка директорий и операций
копирования/перемещения в Subversion. Было видно, что разработчикам поддержка
копирования очень пришлась по душе. Насколько пришлась, что и ветки в Subversion
создаются через копирование, а структура репозитория по-умолчанию - это
знаменитые три директории &lt;code&gt;trunk&lt;/code&gt;, &lt;code&gt;branches&lt;/code&gt; и &lt;code&gt;tags&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Я догадываюсь как принималось это решение. Что-нибудь в духе &amp;ldquo;прикиньте,
одна операция поддерживает и копирование, и ветки, и метки. Не нужно писать
новый код для отдельного пространства имен веток. У нас уже есть этот код&amp;rdquo;. Но
если пересчитать набитые шишки, то становится понятно, что решение было так
себе&amp;hellip; не очень&amp;hellip; совсем хреновое решение это было, как оказалось.&lt;/p&gt;

&lt;p&gt;Почему? А вот почему. Корректная работа с путями файлов, не смотря на кажущуюся
простоту, - это постоянный источник багов. Казалось бы, что тут может быть
сложного, но в результате получается как с указателями - нет, нет, а обязательно
один потеряется. А Subversion заставляет с путями работать.&lt;/p&gt;

&lt;p&gt;Скажем количество шагов в пути для &lt;code&gt;trunk&lt;/code&gt; и &lt;code&gt;branches/foobar&lt;/code&gt; разная. Это
значит, что любой скрипт должен это корректно обработать. Не существует способа
найти все ветки в произвольном репозитории. Операция копирования не обязательно
означает создание ветки - а значит без какого-нибудь соглашения не обойтись.
Ну а мы знаем насколько хорошо &lt;a href=&#34;https://xkcd.com/927/&#34;&gt;люди выдумывают совместимые стандарты&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Использование копирования для создания веток автоматически означает, что
Subversion создать рабочую копию из людой директории в репозитории. Отличная
оптимизация, когда нужно выкачать один файл, но, опять же, это означает, что
скрипты не могут делать массы полезных предположений о структуре репозитория.
Практически сразу же вся эта гибкость запрещается и создается wiki страничка
&amp;ldquo;чекаут делается так, а ветки называются только так, а всех кто делает не так -
прибью нафиг&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Теперь давайте про Git. Линус выбрал другую крайность. Вместо того, чтобы
оставить поддержку копирования для файлов, но сделать нормальные ветки, он
сделал нормальные ветки, но выкорчевал поддержку операций копирования. За одно
под раздачу попали пустые директории.&lt;/p&gt;

&lt;p&gt;Объяснение, как я его понимаю, тут такое - ни копирование, ни пустые директории
с точки зрения самой системы контроля версий не несут полезной информации. Они
совершенно не нужны чтобы корректно отслеживать версии исходного кода. Более
того, эффективное использование Git подразумевает, что никто не анализирует
историю изменений коммит за коммитом. Вместо этого история - это просто такая
база данных, хранящая связи между изменениями в коде, и работать с ней нужно как
с базой данных - с помощью языка запросов, оперируя большими наборами коммитов
(т.е. ветками). Полноценная поддержка операции копирования означает, слияние
веток требует анализа каждого коммита между этими ветками (медленно). Git же
обходится только анализом начального и конечного состояния дерева файлов,
пропуская промежуточные состояния.&lt;/p&gt;

&lt;p&gt;Что же тут плохого, спросите вы? В данном случае проблема упирается в психологию
людей. Да, соглашается подавляющее большинство разработчиков, - поддержка
копирования и пустые директории в принципе не нужны. Но! Мы к ним так привыкли.
Мы хотим линейную историю, явную поддержку копирования и пустые директории.
Нам без них не уютно.&lt;/p&gt;

&lt;p&gt;Вы будете смеяться, но это реальная проблема. Особенно, когда мигрируешь с
Subversion на Git.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Но ведь оно раньше работало. Я мог сделать так и так.&lt;/p&gt;

&lt;p&gt;Полностью согласен, но, на кой, простите, вам это нужно делать именно таким
  способом?&lt;/p&gt;

&lt;p&gt;Но ведь это единственный правильный способ. Мы так всегда делали&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;У нас на работе есть коробка с плюшевыми медведями - специально для таких
случаев. Когда ситуация заходит в тупик и разумные аргументы уже не помогают в
дело вступают плюшевые медведи. Коллеге, чью любимую &lt;a href=&#34;https://xkcd.com/1172/&#34;&gt;фичу пришлось отдать в
жертву прогрессу&lt;/a&gt;, на руки выдается плюшевый медведь - дабы облегчить тяжесть
утраты.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git merge vs git rebase</title>
      <link>https://blog.not-a-kernel-guy.com/2017/09/22/git-merge-rebase/</link>
      <pubDate>Fri, 22 Sep 2017 20:08:39 -0700</pubDate>
      
      <guid>https://blog.not-a-kernel-guy.com/2017/09/22/git-merge-rebase/</guid>
      <description>&lt;p&gt;Прелесть какая:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pbs.twimg.com/media/DJ9dW0BW4AEwGOW.jpg:large&#34;&gt;&lt;img src=&#34;https://blog.not-a-kernel-guy.com/2017/09/git-merge-rebase.jpg&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>